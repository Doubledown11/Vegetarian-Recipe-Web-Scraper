"""
Vegetarian Recipe Web Scraping Project by DoubleDown.

This web scraper will later be used to gather recipe information to be used in my vegan blog website.

This program takes API output from spoontacular.com, formats it into a SQL INSERT statement, adds the writes it to a
user chosen file.

TODO:
* MAYBE --> Allows the user to specify macro and micro nutrient values in the search.

* Add a function to grab the pictures of each recipe received from the API, these pictures will be
used on my vegan recipe blog.

* Feature which allows users to look up substitute ingredients.
    * Add the ability to later filter ingredients by vegan/veg/herb etc... and allow one to search subs off of these
    descriptors.


NOTES:
* Spoontacular API does not return ingredient amounts or ingredient units for each recipe.
* So the current iteration requires users to enter the webpage for each ingredient, in each recipe,
* to gather the ingredient amount, and the ingredient unit type.
    * Later will attempt to generate another GET request on the given URL to try and gather values directly.

"""

import requests
import random
from bs4 import BeautifulSoup

def title_ID(data):
    """Returns the title and recipe ID of recipes generated by user search."""

    results = data['results']
    recipe_titles = []
    recipe_ids = []

    for x in range(len(results)):
        # First grab title
        recipe_titles.append(results[x]['title'])

        # Then grab recipe ID
        recipe_ids.append(results[x]['id'])

    return [recipe_titles, recipe_ids]


def get_summary(data):
    """Finds and returns the recipe summary."""

    results = data['results']
    recipe_descriptions = []

    for x in range(len(results)):
        recipe_descriptions.append(results[x]['summary'])

    return recipe_descriptions


def get_servings(data):
    """Returns the number of servings the recipe yields."""

    results = data['results']
    servings = []

    for x in range(len(results)):
        servings.append(results[x]['servings'])

    return servings


def calories(data):
    """Returns the number of calories per serving of the recipe."""

    results = data['results']
    # calories = []
    soups = []
    calories_list = []

    for x in range(len(results)):
        soup = BeautifulSoup(results[x]['summary'], 'html.parser')
        soups.append(soup)
        # soup.text.index('calories')
        cal_idx = soup.text.index('calories')

        for y in range(len(soup.text)):
            calories_str = soup.text[cal_idx - 5: cal_idx + 8]
            calories_ = int(calories_str.strip('calories'))

            if calories_ not in calories_list:
                calories_list.append(calories_)
                break
            else:
                continue

    return calories_list


def total_time(data):
    """Returns the total time needed to complete this recipe."""

    results = data['results']
    totals = []

    for x in range(len(results)):
        totals.append(results[x]['readyInMinutes'])

    return totals


def prep_time(data):
    """Returns the amount of time needed to prepare cooking this recipe."""

    results = data['results']
    prep = []

    for x in range(len(results)):
        if results[x]['preparationMinutes'] != -1:
            prep.append(results[x]['preparationMinutes'])
        elif results[x]['preparationMinutes'] == -1:
            prep.append('NULL')

    return prep


def cook_time(data):
    """Returns the amount of time needed to cook this recipe."""

    results = data['results']

    cook_times = []

    for x in range(len(results)):
        if results[x]['cookingMinutes'] != -1:
            cook_times.append(results[x]['cookingMinutes'])
        elif results[x]['cookingMinutes'] == -1 or results[x]['cookingMinutes'] == 0:
            cook_times.append('NULL')

    return cook_times


def get_course(data):
    """Returns the course that the recipe is considered."""

    results = data['results']
    course_descriptions = []

    for x in range(len(results)):
        if len(results[x]['dishTypes']) > 0:
            course_descriptions.append([results[x]['dishTypes']])
        else:
            course_descriptions.append(['NULL'])

    return course_descriptions


def get_cuisines(data):
    """Finds and returns the cuisines descriptions for each recipe if they have any."""

    results = data['results']
    cuisines = []

    for x in range(len(results)):
        if len(results[x]['cuisines']) >= 1:
            cuisines.append([results[x]['cuisines']])
        else:
            cuisines.append(['NULL'])

    return cuisines


def get_ingredient_id(data):
    """ Finds and returns the ingredient ID of each ingredient for each recipe."""

    results = data['results']
    ingredient_id = []

    for x in range(len(results)):
        ingredients_in_recipe = []
        for y in range(len(results[x]['analyzedInstructions'])):
            for z in range(len(results[x]['analyzedInstructions'][y]['steps'])):
                for a in range(len(results[x]['analyzedInstructions'][y]['steps'][z]['ingredients'])):
                    ingredients = results[x]['analyzedInstructions'][y]['steps'][z]['ingredients'][a]
                    if ingredients['id'] not in ingredient_id:
                        ingredients_in_recipe.append(ingredients['id'])
                    else:
                        continue

        if ingredients_in_recipe not in ingredient_id:
            ingredient_id.append(ingredients_in_recipe)
        else:
            continue

    return ingredient_id


def get_instructions(data):
    """Returns all instructions for each recipe returned."""

    results = data['results']
    instructions = []

    for x in range(len(results)):
        for y in range(len(results[x]['analyzedInstructions'])):

            # At this point ingredients are found within the output for steps.
            # So I have to iterate through each step dictionary, and find the key which contains the needed information.
            recipe_instructions = []
            for z in range(len(results[x]['analyzedInstructions'][y]['steps'])):
                recipe_instructions.append(results[x]['analyzedInstructions'][y]['steps'][z]['step'])

            if recipe_instructions not in instructions:
                instructions.append(recipe_instructions)
            else:
                continue

    return instructions


def get_ingredient_names(data):
    """Returns the names of all the ingredients in all recipes returned from the API."""

    results = data['results']
    ingredient_names = []

    for x in range(len(results)):
        ingredients_in_recipe = []
        for y in range(len(results[x]['analyzedInstructions'])):
            for z in range(len(results[x]['analyzedInstructions'][y]['steps'])):
                for a in range(len(results[x]['analyzedInstructions'][y]['steps'][z]['ingredients'])):
                    ingredients = results[x]['analyzedInstructions'][y]['steps'][z]['ingredients'][a]
                    if ingredients['name'] not in ingredient_names:
                        ingredients_in_recipe.append(ingredients['name'])
                    else:
                        continue

        if ingredients_in_recipe not in ingredient_names:
            ingredient_names.append(ingredients_in_recipe)
        else:
            continue

    return ingredient_names


def get_occasions(data):
    """Finds and returns the tags descriptions for each recipe returned from the API."""

    results = data['results']
    occasions = []

    for x in range(len(results)):
        if len(results[x]['occasions']) <= 0:
            occasions.append(['NULL'])
        else:
            occasions.append([results[x]['occasions']])

    return occasions


def get_diets(data):
    """Finds and returns the diet descriptions of each recipe returned from the API."""

    results = data['results']
    diets = []

    for x in range(len(results)):
        if len(results[x]['diets']) <= 0:
            diets.append(['NULL'])

        elif results[x]['diets'] not in diets:
            diets.append([results[x]['diets']])

        else:
            continue

    return diets


def get_dish_types(data):
    """Finds and returns all dish type descriptions for each recipe returned from the API."""

    results = data['results']
    dish_types = []

    for x in range(len(results)):
        if len(dish_types) <= 0:
            dish_types.append(['NULL'])
        elif results[x]['dishTypes'] not in dish_types:
            dish_types.append([results[x]['dishTypes']])
        else:
            continue

    return dish_types


def get_cost_per_serving(data):
    """Finds and returns the cost per servings for each recipe returned from the API."""

    results = data['results']
    price_per_serving = []

    for x in range(len(results)):
        if type(results[x]['pricePerServing']) != float:
            price_per_serving.append('NULL')
        elif results[x]['pricePerServing'] not in price_per_serving:
            price_per_serving.append(results[x]['pricePerServing'])
        else:
            continue

    return price_per_serving


def get_smart_points(data):
    """Finds and returns the weight watchers smart points amount for each recipe returned from the API."""

    results = data['results']
    smart_points = []

    for x in range(len(results)):
        if type(results[x]['weightWatcherSmartPoints']) != float:
            smart_points.append('NULL')
        else:
            smart_points.append(results[x]['weightWatcherSmartPoints'])

    return smart_points


def get_dairy_free(data):
    """Finds and returns the Boolean value indicating if the recipe is dairy free."""

    results = data['results']
    dairy_free = []

    for x in range(len(results)):
        dairy_free.append(results[x]['dairyFree'])

    return dairy_free


def get_gluten_free(data):
    """Finds and returns the Boolean value indicating if the recipe is gluten free."""

    results = data['results']
    gluten_free = []

    for x in range(len(results)):
        gluten_free.append(results[x]['glutenFree'])

    return gluten_free


def get_vegan(data):
    """Finds and returns the Boolean value indicating if the recipe is vegan."""

    results = data['results']
    vegan = []

    for x in range(len(results)):
        vegan.append(results[x]['vegan'])

    return vegan


def get_recipe_origin(data):
    """Finds and returns the origin website for each recipe returned from the API, if the information is included."""

    results = data['results']
    origins = []

    for x in range(len(results)):
        if results[x]['sourceName'] not in origins:
            origins.append(results[x]['sourceName'])
        else:
            continue

    return origins


def recipe_statements(recipe_ID, recipe_title, recipe_summary, prep, cook_, tot_time,
                      recipe_servings, cuisines, cal, course, filename):
    """Creates and write the SQL insert statements to the specified file."""

    with open(filename, 'r') as file:
        for x in range(len(recipe_title)):

            # Code block below forms a single string out of all recipe cuisines returned.
            if len(cuisines[x]) > 1:
                cuisines = ''
                for y in range(len(cuisines[x])):
                    cuisines += str(cuisines[x][y])
                    cuisines += ' '

            cuisines[x] = cuisines

            # Reduce the Recipe summary to a max of 500 chars.
            if len(recipe_summary[x]) > 500:
                for y in range(len(recipe_summary[x])):
                    recipe_summary[x] = recipe_summary[x][0:500]

            # Line below forms a single string out of all recipe course values returned.
            if len(course[x]) > 1:
                courses = ''
                for y in range(len(course[x])):
                    courses += str(course[x])
                    courses += ' '

            course[x] = courses

            insert_statement = f'INSERT INTO Recipes VALUES ({recipe_ID[x]}, {recipe_title[x]}, {recipe_summary[x]}, ' \
                               f'{prep[x]}, {cook_[x]}, {tot_time[x]}, {recipe_servings[x]}, {cuisines[x]}, {cal[x]},' \
                               f' {course[x]});'

            # Should check the file to ensure the recipe pulled from the API has not already been written.
            existing_statements = file.read()
            if insert_statement not in existing_statements:
                with open(filename, 'w') as file_write:
                    file_write.write(insert_statement + '\n')
            else:
                continue


def ingredient_statements(ingredient_IDs, ingredient_names, filename):
    """Creates and write the SQL insert statements to the specified file."""

    with open(filename, 'r') as file:

        # Below is the for loop used to create and write the INSERT statement for the Ingredients table.
        for x in range(len(ingredient_names)):
            # Create an input statement asking for user input on ingredient category, description, quantity on hand,
            # and price per unit. (MAYBE use walmart API, price API, Amazon Product Advertising API)
            print('Example Ingredient Categories:\n'
                  'Vegetables.\n'
                  'Fruits.\n'
                  'Grains.\n'
                  'Legumes/Beans.\n'
                  'Nuts/Seeds.\n'
                  'Plant Protein.\n'
                  'Dairy Alternatives.\n'
                  'Herbs/Spices.\n'
                  'Condiments/Sauces.\n'
                  'Sweeteners.\n'
                  'Flours/Baking Ingredients.\n'
                  'Oils.\n'
                  'Miscellaneous.\n')
            print('For input below, make sure to enter category input exactly as seen above. (Minus the punctuation) ')

            recipe_categories = ['Vegetables', 'Fruits', 'Grains', 'Legumes/Beans', 'Nuts/Seeds', 'Plant Protein',
                                 'Dairy Alternatives', 'Herbs/Spices', 'Condiments/Sauces', 'Sweeteners',
                                 'Flours/Baking', 'Oils', 'Miscellaneous']

            # Later add various exceptions cleansing user input.
            while True:
                category = input(f"What would the category classification for the ingredient "
                             f"{ingredient_names[x]} be?: ").capitalize()

                if category not in recipe_categories:
                    print(f'Category {category}, is not valid. Please select a category from the previously displayed list.')
                else:
                    break

            print('\n\n')
            print(f'Please enter a short description on the following ingredient: {ingredient_names[x]}')
            description = input("Enter description here: ")

            print('\n\n')
            print(f'Please enter the quantity on hand of the following ingredient: {ingredient_names[x]}')

            while True:
                quantity_on_hand = input('Enter quantity on hand here (Enter to 2 decimal places): ')

                if type(quantity_on_hand) == float:
                    break
                else:
                    print("Quantity on hand value entered is invalid. Please try again. ")

            # As I have collected our missing attribute values from user input,
            # I can now finish creating the INSERT statement.

            insert_statement = f'INSERT INTO Ingredients VALUES ({ingredient_IDs[x]}, {ingredient_names[x]}, ' \
                               f'{category}, {description}, {quantity_on_hand});'

            # Should check the file to ensure the ingredients pulled from the API has not already been written.
            existing_statements = file.read()
            if insert_statement not in existing_statements:
                with open(filename, 'w') as file_write:
                    file_write.write(insert_statement + '\n')
            else:
                continue


def instructions_statements(recipe_ID, instructions_per_recipe, filename):
    """Creates and write the SQL insert statements to the specified file."""

    # Lists: instructions_per_recipe

    with open(filename, 'r') as file:

        # Below is the for loop used to create and write the INSERT statement for the Instructions table.
        for x in range(len(recipe_ID)):
            step_number = 0

            # Below code generates a random value to use as the ingredient ID, and numbers the instructions as steps.
            for y in instructions_per_recipe[x]:
                instruction_ID = random.randint(1, 10000)
                step_number +=1

                # As we finished creating our missing table values, we can now form the INSERT statement.
                insert_statement = f'INSERT INTO Instructions VALUES ({instruction_ID}, {recipe_ID[x]}, {step_number},' \
                               f'{instructions_per_recipe[x][y]});'

                # Should check the file to ensure the ingredients pulled from the API has not already been written.
                existing_statements = file.read()
                if insert_statement not in existing_statements:
                    with open(filename, 'w') as file_write:
                        file_write.write(insert_statement + '\n')
                else:
                    continue


def tags_statements(recipe_ID, occasions, diets, dish_types, cost_serving, smart_points, dairy_free,
                    gluten_free, vegan_tag, filename):
    """Creates and write the SQL insert statements to the specified file."""


    with open(filename, 'r') as file:

        for x in range(len(recipe_ID)):
            recipe_occasions = ''
            recipe_diets = ''
            recipe_dish_types = ''

            # Code block below forms a single string out of all recipe cuisines returned.
            if len(occasions) > 1:
                recipe_occasions = occasions[x]
                recipe_occasions += ' '

            occasions[x] = recipe_occasions


            # Code block below forms a single string out of all recipe diets returned.
            if len(diets) > 1:
                recipe_diets += diets[x]
                recipe_diets += ' '

            diets[x] = recipe_diets

            # Code block below forms a single string out of all recipe dish types returned.
            if len(dish_types) > 1:
                recipe_dish_types += dish_types[x]
                recipe_dish_types += ' '

            dish_types[x] = recipe_dish_types

            """
            NEED TO CREATE TAG ID, AND USE IT IN THE INSERT STATEMENT.
            """

            # As we have finished creating our missing attribute values, we can form our INSERT statement.
            insert_statement = f'INSERT INTO Ingredients VALUES ({recipe_ID[x]}, {occasions[x]}, {diets[x]},' \
                               f'{dish_types[x]}, {cost_serving[x]}, {smart_points[x]}, {dairy_free[x]},' \
                               f' {gluten_free[x]}, {vegan_tag[x]});'

            # Should check the file to ensure the ingredients pulled from the API has not already been written.
            existing_statements = file.read()
            if insert_statement not in existing_statements:
                with open(filename, 'w') as file_write:
                    file_write.write(insert_statement + '\n')
            else:
                continue


def recipe_ingredients_statements(recipe_ID, ingredient_IDs, ingredient_names, filename, data):
    """Creates and write the SQL insert statements to the specified file."""

    results = data['results']

    with open(filename, 'r') as file:

        # Input functions asking for the ingredient amount and units.

        # Below is the for loop used to create and write the INSERT statement for the Recipe_Ingrediants table.
        for x in range(len(recipe_ID)):
            recipe_ingredient_ID = random.randint(0,10000)

            # Below is the code block used to gather ingredient amount.
            for y in range(len(ingredient_names[x])):
                spoontacular_source_URL = results[x]['spoonacularSourceUrl']

                # Below loop verifies user ingredient amount input.
                while True:
                    print('Use the following URL to gather ingredient amount values.')
                    print(spoontacular_source_URL, '\n')
                    ingredient_amount = input(f"Please enter the amount of the following ingredient, "
                                          f"{ingredient_names[x][y]} from the recipe with id of {recipe_ID[x]}: "
                                          f"")

                    if type(ingredient_amount) != float or type(ingredient_amount) != int:
                        print('Ingredient Amount entered invalid! Please enter ingredient amount as either a float or int. ')
                        continue
                    else:
                        break

                # Below loop verifies user ingredient unit type input.
                while True:
                    print('Use the following URL to gather ingredient unit values.')
                    print(spoontacular_source_URL, '\n')
                    print('Please enter the following input as a string')
                    ingredient_units = input(f"Please enter the units used for the ingredient {ingredient_names[x][y]}:"
                                             f" ")

                    if type(ingredient_units) != str:
                        print('Ingredient units entered is invalid, please try again!')
                        continue
                    else:
                        break

            for y in range(len(ingredient_IDs[x])):
                insert_statement = f'INSERT INTO Recipe_Ingredients VALUES ({recipe_ingredient_ID}, {recipe_ID[x]}, ' \
                                   f'{ingredient_IDs[x][y]}, {ingredient_amount}, {ingredient_units}'

                # Should check the file to ensure the ingredients pulled from the API has not already been written.
                existing_statements = file.read()
                if insert_statement not in existing_statements:
                    with open(filename, 'w') as file_write:
                        file_write.write(insert_statement + '\n')
                else:
                    continue


def recipe_origin_statements(recipe_origins, recipe_ID, filename):
    """Creates and write the SQL insert statements to the specified file."""

    with open(filename, 'r') as file:

        for x in range(len(recipe_ID)):
            insert_statement = f'INSERT INTO Recipe_Origin VALUES({recipe_ID[x]}, {recipe_origins[x]});'

            # Should check the file to ensure the ingredients pulled from the API has not already been written.
            existing_statements = file.read()
            if insert_statement not in existing_statements:
                with open(filename, 'w') as file_write:
                    file_write.write(insert_statement + '\n')
            else:
                continue


def get_recipe_image(data):
    """Finds and returns the hyperlink for the recipe images used on spoontacular."""
    #TODO: pass


def main():
    """Main Function."""

    url = 'https://api.spoonacular.com/recipes/complexSearch'
    api_key = 'ae1614a29fa0427d872fd8ae4733cb5c'
    diet = 'vegetarian'

    params = {'apiKey':api_key, 'diet':diet, 'addRecipeInformation':True}

    data = requests.get(url, params=params)
    if data.status_code == 200:
        data = data.json()
    elif data.status_code == 402:
        print('You are out of free withdrawals from the Spoontacular API!')
    else:
        print(data.status_code)



################# Recipe Table ##################
    # Recipe ID and Recipe Title:
    title_RecipeID = title_ID(data)
    recipe_title = title_RecipeID[0]
    recipe_ID = title_RecipeID[1]

    # Recipe Description
    recipe_summary = get_summary(data)

    # Prep time
    prep = prep_time(data)

    # Total Time
    tot_time = total_time(data)

    # Cook time
    cook_ = cook_time(data)

    # Servings
    recipe_servings = get_servings(data)

    # Cuisine
    cuisines = get_cuisines(data)

    # Calories
    cal = calories(data)

    # Course
    course = get_course(data)

####################################

##### Ingredients Table ##########

    # Ingredient IDs
    ingredient_IDs = get_ingredient_id(data)

    # Ingredient Names
    ingredient_names = get_ingredient_names(data)

###################################

##### Instructions Table ##########
# Instructions 'Instruction' attribute:
    instructions_per_recipe = get_instructions(data)


###################################

##### Tags ########################
# Occasions Tag
    occasions = get_occasions(data)

# Diets Tag
    diets = get_diets(data)

# Dish Types Tag
    dish_types = get_dish_types(data)

# Cost per servings Tag
    cost_serving = get_cost_per_serving(data)

# Weight Watcher's Smart Points Tag
    smart_points = get_smart_points(data)

# Dairy Free Tag
    dairy_free = get_dairy_free(data)

# Gluten Free Tag
    gluten_free = get_gluten_free(data)

# Vegan Tag
    vegan_tag = get_vegan(data)

###############################

#### Recipe_Origin ############
# Recipe Origin Website
    recipe_origins = get_recipe_origin(data)

###############################

    # After I have gathered all data needed for filling my database tables,
    #  I format everything into SQL insert into statements.
    # Then append those SQL statements to a txt file that is saved on my machine,
    # and this file can be run in MySQL Server.


    # Below while loop verifies that the user input filename is valid.
    while True:
        filename = input("What would you like to name the file of which to save the SQL output?: ").capitalize()
        if type(filename) == str:
            filename += '.txt'
            break
        else:
            continue


    # Line below calls the function which creates and writes the SQL statements for the Recipes table.
    recipe_statements(recipe_ID, recipe_title, recipe_summary, prep, cook_, tot_time,
                      recipe_servings, cuisines, cal, course, filename)

    # Line below calls the function which creates and writes the SQL statements for the Ingredients table.
    ingredient_statements(ingredient_IDs, ingredient_names, filename)

    # Line below calls the function which creates and writes the SQL statements for the Instructions table.
    instructions_statements(recipe_ID, instructions_per_recipe, filename)

    # Line below calls the function which creates and writes the SQL statements for the Tags table.
    tags_statements(recipe_ID, occasions, diets, dish_types, cost_serving, smart_points, dairy_free,
                    gluten_free, vegan_tag, filename)

    # Line below calls the function which creates and writes the SQL statements for the Recipe_Ingredients table.
    recipe_ingredients_statements(recipe_ID, ingredient_IDs, ingredient_names, filename, data)

    # Line below calls the function which creates and writes the SQL statements for the Recipe_Origin table.
    recipe_origin_statements(recipe_origins, recipe_ID, filename)


if __name__ == '__main__':
    main()

